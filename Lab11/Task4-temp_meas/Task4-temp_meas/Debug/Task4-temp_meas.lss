
AVRASM ver. 2.2.7  F:\Fall_2020\ESE_280\Labatory\11\Code\Task4-temp_meas\Task4-temp_meas\main.asm Fri Nov 20 10:01:55 2020

F:\Fall_2020\ESE_280\Labatory\11\Code\Task4-temp_meas\Task4-temp_meas\main.asm(23): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
F:\Fall_2020\ESE_280\Labatory\11\Code\Task4-temp_meas\Task4-temp_meas\main.asm(287): warning: Register r18 already defined by the .DEF directive
F:\Fall_2020\ESE_280\Labatory\11\Code\Task4-temp_meas\Task4-temp_meas\main.asm(288): warning: Register r19 already defined by the .DEF directive
F:\Fall_2020\ESE_280\Labatory\11\Code\Task4-temp_meas\Task4-temp_meas\main.asm(533): warning: Register r16 already defined by the .DEF directive
F:\Fall_2020\ESE_280\Labatory\11\Code\Task4-temp_meas\Task4-temp_meas\main.asm(534): warning: Register r17 already defined by the .DEF directive
F:\Fall_2020\ESE_280\Labatory\11\Code\Task4-temp_meas\Task4-temp_meas\main.asm(536): warning: Register r18 already defined by the .DEF directive
F:\Fall_2020\ESE_280\Labatory\11\Code\Task4-temp_meas\Task4-temp_meas\main.asm(537): warning: Register r19 already defined by the .DEF directive
F:\Fall_2020\ESE_280\Labatory\11\Code\Task4-temp_meas\Task4-temp_meas\main.asm(630): warning: Register r13 already defined by the .DEF directive
F:\Fall_2020\ESE_280\Labatory\11\Code\Task4-temp_meas\Task4-temp_meas\main.asm(631): warning: Register r14 already defined by the .DEF directive
F:\Fall_2020\ESE_280\Labatory\11\Code\Task4-temp_meas\Task4-temp_meas\main.asm(632): warning: Register r15 already defined by the .DEF directive
F:\Fall_2020\ESE_280\Labatory\11\Code\Task4-temp_meas\Task4-temp_meas\main.asm(633): warning: Register r19 already defined by the .DEF directive
F:\Fall_2020\ESE_280\Labatory\11\Code\Task4-temp_meas\Task4-temp_meas\main.asm(663): warning: Register r14 already defined by the .DEF directive
F:\Fall_2020\ESE_280\Labatory\11\Code\Task4-temp_meas\Task4-temp_meas\main.asm(664): warning: Register r15 already defined by the .DEF directive
F:\Fall_2020\ESE_280\Labatory\11\Code\Task4-temp_meas\Task4-temp_meas\main.asm(665): warning: Register r16 already defined by the .DEF directive
F:\Fall_2020\ESE_280\Labatory\11\Code\Task4-temp_meas\Task4-temp_meas\main.asm(666): warning: Register r17 already defined by the .DEF directive
F:\Fall_2020\ESE_280\Labatory\11\Code\Task4-temp_meas\Task4-temp_meas\main.asm(667): warning: Register r18 already defined by the .DEF directive
F:\Fall_2020\ESE_280\Labatory\11\Code\Task4-temp_meas\Task4-temp_meas\main.asm(23): Including file 'C:/Program Files (x86)\Atmel\Studio\7.0\Packs\atmel\ATmega_DFP\1.3.300\avrasm\inc\m4809def.inc'
                                 
                                 
                                 ;*
                                 ;* Title: temp_meas
                                 ;* Author: Aditya Jindal
                                 ;* Version:	1.0
                                 ;* Last updated: 11082020
                                 ;* Target: ATmega4809
                                 ;*
                                 ;* DESCRIPTION: Use PE3 as an analog input for a
                                 ;* temperature sensor, convert the digital output
                                 ;* to packed bcd and then display to led_display
                                 ;* values displayed is the decimal value of the
                                 ;* temperature
                                 ;* 
                                 ;* 
                                 ;*
                                 ;*
                                 ;* VERSION HISTORY
                                 ;* 1.0 Original version
                                 ;******************************************************
                                 
                                 .list
                                 
                                 .equ PERIOD_EXAMPLE_VALUE = 64
                                 
                                 ;* Define varaibles
                                 .dseg
002800                           bcd_entries: .byte 4
002804                           led_display: .byte 4
002808                           digit_num: .byte 1
                                 
                                 ;Task 4
                                 .cseg			;start of code segment
                                 reset:
000000 940c 002e                  	jmp start	;reset vector executed a power on
                                 
                                 .org TCA0_OVF_vect
00000e 940c 0067                 	jmp toggle_pin_ISR
                                 .org ADC0_RESRDY_vect
00002c 940c 007e                 	jmp analog_pin_ISR
                                 
                                 start:
00002e e200                      	ldi r16, 0x20	;set 2.5V as teh reference
00002f 9300 00a0                 	sts VREF_CTRLA, r16
                                 
000031 e004                      	ldi r16, 0x04 	;configure PE3 to work as ADC
000032 9300 0493                 	sts PORTE_PIN3CTRL, r16
                                 
000034 e001                      	ldi r16, 0x01	;set the mode for the ADC
000035 9300 0600                 	sts ADC0_CTRLA, r16
                                 
000037 e005                      	ldi r16, 0x05	;set the prescaller
000038 9300 0602                 	sts ADC0_CTRLC, r16
                                 
00003a e00b                      	ldi r16, 0x0B	;set the analog input
00003b 9300 0606                 	sts ADC0_MUXPOS, r16
                                 
00003d e001                      	ldi r16, 0x01	;start the ADC
00003e 9300 0608                 	sts ADC0_COMMAND, r16 
                                 
                                 
000040 ef0f                      	ldi r16, 0xFF ;make r16 all 1s
000041 b90c                      	out VPORTD_DIR, r16; make portD to output
                                 
000042 ef00                      	ldi r16, 0xF0
000043 b908                      	out VPORTC_DIR, r16 ;top pins of portC to output
                                 
                                 	;Initialize vairables and arrays	
000044 e000                      	ldi r16, 0x00;
000045 9300 2808                 	sts digit_num, r16 ;Initialize digit_num variable
                                 
000047 e2d8                      	ldi YH, HIGH(bcd_entries)	;set pointer to end of array
000048 e0c0                      	ldi YL, LOW(bcd_entries)	;set pointer to start of array
                                 	
000049 8308                      	std Y+0 ,r16		;initialize bcd_entried
00004a 8309                      	std Y+1 ,r16
00004b 830a                      	std Y+2 ,r16
00004c 830b                      	std Y+3 ,r16
                                 
00004d ef0f                      	ldi r16, 0xFF
00004e e2b8                      	ldi XH, HIGH(led_display);set pointer to end of array
00004f e0a4                      	ldi XL, LOW(led_display);set pointer to start of array
                                 
000050 930d                      	st X+ ,r16 ;initalize LED display array
000051 930d                      	st X+ ,r16 ;initalize LED display array
000052 930d                      	st X+ ,r16 ;initalize LED display array
000053 930d                      	st X+ ,r16 ;initalize LED display array
                                 
                                 	;configure TCA0
000054 e000                      	ldi r16, TCA_SINGLE_WGMODE_NORMAL_gc	;WGMODE normal
000055 9300 0a01                 	sts TCA0_SINGLE_CTRLB, r16
                                 
000057 e001                      	ldi r16, TCA_SINGLE_OVF_bm		;enable overflow interrupt
000058 9300 0a0a                 	sts TCA0_SINGLE_INTCTRL, r16
                                 
                                 	;load period low byte then high byte
00005a e400                      	ldi r16, LOW(PERIOD_EXAMPLE_VALUE)	;set the period
00005b 9300 0a26                 	sts TCA0_SINGLE_PER, r16
00005d e000                      	ldi r16, HIGH(PERIOD_EXAMPLE_VALUE)	;set the period
00005e 9300 0a27                 	sts TCA0_SINGLE_PER + 1, r16
                                 
                                 	;set clock and start timer
000060 e00d                      	ldi r16, TCA_SINGLE_CLKSEL_DIV256_gc | TCA_SINGLE_ENABLE_bm
000061 9300 0a00                 	sts TCA0_SINGLE_CTRLA, r16
                                 
000063 9478                      	sei		;enable global interrupts
                                 
000064 d06d                      	rcall post_display
                                 
                                 main_loop:
000065 d02c                      	rcall signal_conv ;poll signal conerstion	
000066 cffe                      	rjmp main_loop ;loop back
                                 
                                 toggle_pin_ISR:
000067 930f                      	push r16	;save reister values in stack
000068 b70f                      	in r16, CPU_SREG
000069 930f                      	push r16
00006a 931f                      	push r17
00006b 932f                      	push r18
00006c 933f                      	push r19
00006d 934f                      	push r20
00006e 93df                      	push YH			;save YH pointer
00006f 93cf                      	push YL			;save YL pointer
                                 
000070 d07e                      	rcall multiplex_display	;call subroutine
                                 
000071 e001                      	ldi r16, TCA_SINGLE_OVF_bm	;clear OVF flag
000072 9300 0a0b                 	sts TCA0_SINGLE_INTFLAGS, r16
                                 
000074 91cf                      	pop YL	;restore stack values to registers
000075 91df                      	pop YH
000076 914f                      	pop r20
000077 913f                      	pop r19
000078 912f                      	pop r18
000079 911f                      	pop r17
00007a 910f                      	pop r16
00007b bf0f                      	out CPU_SREG, r16
00007c 910f                      	pop r16
                                 
00007d 9518                      	reti
                                 
                                 
                                 analog_pin_ISR:
00007e 930f                      	push r16	;save register values in a stack
00007f b70f                      	in r16, CPU_SREG
000080 930f                      	push r16
000081 931f                      	push r17
000082 932f                      	push r18
000083 933f                      	push r19
000084 934f                      	push r20
000085 93df                      	push YH			;save YH pointer
000086 93cf                      	push YL			;save YL pointer
                                 
000087 d00a                      	rcall signal_conv ;call subroutine
                                 
000088 91cf                      	pop YL	;restore stack valuues to register
000089 91df                      	pop YH
00008a 914f                      	pop r20
00008b 913f                      	pop r19
00008c 912f                      	pop r18
00008d 911f                      	pop r17
00008e 910f                      	pop r16
00008f bf0f                      	out CPU_SREG, r16
000090 910f                      	pop r16
                                 
000091 9518                      	reti
                                 
                                 ;**************************************************
                                 ;* 
                                 ;* "signal_conv"
                                 ;*
                                 ;* Description: convert the temperature signal from
                                 ;* analog to digital
                                 ;*
                                 ;* Author: Aditya Jindal
                                 ;* Version: 1.0
                                 ;* Last updated:
                                 ;* Target: ATmega4809
                                 ;* Number of words: 47
                                 ;* Number of cycles: 102
                                 ;* Low registers modified: none
                                 ;* High registers modified: r14, r15, r16, r18, r19
                                 ;*							r20, r21, r22, r23, r24
                                 ;*							XL, XH
                                 ;*
                                 ;* Parameters: none
                                 ;* Returns: none
                                 ;*
                                 ;* Notes: 
                                 ;*
                                 ;***********************************************
                                 
                                 signal_conv:
                                 	;\sensors data and load it into LED display
000092 9100 0610                 	lds	mc16uL, ADC0_RESL	;set multi subroutine inputs
000094 9110 0611                 	lds	mc16uH, ADC0_RESH
000096 ec24                      	ldi	mp16uL, LOW(2500)
000097 e039                      	ldi	mp16uH, HIGH(2500)
000098 d02a                      	rcall	mpy16u	;call 16 x 16 multiplex subroutine
                                 
000099 2f23                      	mov r18, r19;this shift the result 8 bits to the right
00009a 2f34                      	mov r19, r20
00009b 2f45                      	mov r20, r21
00009c e050                      	ldi r21, 0x00
                                 
00009d e062                      	ldi r22, 2	;shift the result 2 bits to the right
                                 right_shift_loop:				
00009e 9536                      	lsr r19 ;shift another result right
00009f 9527                      	ror r18
0000a0 956a                      	dec r22
0000a1 f7e1                      	brne right_shift_loop
                                 
                                 ;Subtract 500 from the product
0000a2 e081                      	ldi r24, HIGH(500)	;set negative 500 to two regiters
0000a3 ef74                      	ldi r23, LOW(500)
                                 
0000a4 1b27                      	sub r18, r23	;add which is subtracting in this case
0000a5 0b38                      	sbc r19, r24	;add with carry
                                 
0000a6 2f02                      	mov r16, r18	;prepare values for BCD2bin16 subroutine
0000a7 2f13                      	mov r17, r19
                                 
0000a8 d06a                      	rcall bin2BCD16	;call subroutine
                                 
0000a9 e2b8                      	ldi XH, HIGH(led_display);set pointer to end of array
0000aa e0a4                      	ldi XL, LOW(led_display);set pointer to start of array
                                 
0000ab 2d2d                      	mov r18, r13
0000ac d0b7                      	rcall hex_to_7seg	;call subroutine
0000ad 932d                      	st X+ ,r18	;store result in led array
                                 
0000ae 2d2d                      	mov r18, r13
0000af 9526                      	lsr r18			;shift first value to msb
0000b0 9526                      	lsr r18
0000b1 9526                      	lsr r18
0000b2 9526                      	lsr r18
                                 	
0000b3 d0b0                      	rcall hex_to_7seg
                                 	;andi r18, ~0x08	;turn on decimal (probably wrong)
0000b4 932d                      	st X+ ,r18
                                 
0000b5 2d2e                      	mov r18, r14
0000b6 d0ad                      	rcall hex_to_7seg
0000b7 932d                      	st X+,r18
                                 
0000b8 2d2e                      	mov r18, r14
0000b9 9526                      	lsr r18			;shift first value to msb
0000ba 9526                      	lsr r18
0000bb 9526                      	lsr r18
0000bc 9526                      	lsr r18
                                 	
0000bd d0a6                      	rcall hex_to_7seg
0000be 932d                      	st X+,r18
                                 
0000bf e001                      	ldi r16, 0x01	;start the converstion
0000c0 9300 0608                 	sts ADC0_COMMAND, r16 
                                 
0000c2 9508                      	ret
                                 
                                 ;**************************************
                                 ;*
                                 ;* "mpy16u" - 16x16 Bit Unsigned Multiplication
                                 ;*
                                 ;* This subroutine multiplies 
                                 ;* the two 16-bit register variables 
                                 ;* mp16uH:mp16uL and mc16uH:mc16uL.
                                 ;* The result is placed in 
                                 ;* m16u3:m16u2:m16u1:m16u0.
                                 ;*  
                                 ;* Number of words	:14 + return
                                 ;* Number of cycles	:153 + return
                                 ;* Low registers used	:None
                                 ;* High registers used  :7 (mp16uL,mp16uH,mc16uL/m16u0,
                                 ;*							mc16uH/m16u1,m16u2,
                                 ;*                          m16u3,mcnt16u)	
                                 ;*
                                 ;********************************
                                 
                                 ;***** Subroutine Register Variables
                                 
                                 .def	mc16uL	=r16	;multiplicand low byte
                                 .def	mc16uH	=r17	;multiplicand high byte
                                 .def	mp16uL	=r18	;multiplier low byte
                                 .def	mp16uH	=r19	;multiplier high byte
                                 .def	m16u0	=r18	;result byte 0 (LSB)
                                 .def	m16u1	=r19	;result byte 1
                                 .def	m16u2	=r20	;result byte 2
                                 .def	m16u3	=r21	;result byte 3 (MSB)
                                 .def	mcnt16u	=r22	;loop counter
                                 
                                 ;***** Code
                                 
0000c3 2755                      mpy16u:	clr	m16u3	;clear 2 highest bytes of result
0000c4 2744                      	clr	m16u2
0000c5 e160                      	ldi	mcnt16u,16	;init loop counter
0000c6 9536                      	lsr	mp16uH
0000c7 9527                      	ror	mp16uL
                                 
0000c8 f410                      m16u_1:	brcc	noad8	;if bit 0 of multiplier set
0000c9 0f40                      	add	m16u2,mc16uL;add multiplicand Low to byte 2 of res
0000ca 1f51                      	adc	m16u3,mc16uH;add multiplicand high to byte 3 of res
0000cb 9557                      noad8:	ror	m16u3	;shift right result byte 3
0000cc 9547                      	ror	m16u2	;rotate right result byte 2
0000cd 9537                      	ror	m16u1	;rotate result byte 1 and multiplier High
0000ce 9527                      	ror	m16u0	;rotate result byte 0 and multiplier Low
0000cf 956a                      	dec	mcnt16u	;decrement loop counter
0000d0 f7b9                      	brne	m16u_1	;if not done, loop more
0000d1 9508                      	ret
                                 
                                 
                                 ;**************************************************
                                 ;* 
                                 ;* "post_display"
                                 ;*
                                 ;* Description: outputs the segment values for the 
                                 ;*	next multiplexed digit to be displayed and turns
                                 ;*	ON that digit
                                 ;*
                                 ;* Author: Aditya Jindal
                                 ;* Version: 1.0
                                 ;* Last updated: 10-29-2020
                                 ;* Target: ATmega4809
                                 ;* Number of words: 32
                                 ;* Number of cycles: 36
                                 ;* Low registers modified: none
                                 ;* High registers modified: r16, XH, XL
                                 ;*
                                 ;* Parameters: none
                                 ;* Returns: none
                                 ;*
                                 ;* Notes: 
                                 ;*
                                 ;***********************************************
                                 
                                 post_display:
                                 	;Turn on all segements
0000d2 e000                      	ldi r16, 0x00
0000d3 e2b8                      	ldi XH, HIGH(led_display);set pointer to end of array
0000d4 e0a4                      	ldi XL, LOW(led_display);set pointer to start of array
                                 
0000d5 930d                      	st X+ ,r16 ;initalize LED display array
0000d6 930d                      	st X+ ,r16 ;initalize LED display array
0000d7 930d                      	st X+ ,r16 ;initalize LED display array
0000d8 930d                      	st X+ ,r16 ;initalize LED display array
                                 	
0000d9 e227                      	ldi r18, 39
0000da d00f                      	rcall one_sec_delay	;one second delay
                                 
                                 	;Turn all segments off
0000db ef0f                      	ldi r16, 0xFF
0000dc e2b8                      	ldi XH, HIGH(led_display);set pointer to end of array
0000dd e0a4                      	ldi XL, LOW(led_display);set pointer to start of array
                                 
0000de 930d                      	st X+ ,r16 ;initalize LED display array
0000df 930d                      	st X+ ,r16 ;initalize LED display array
0000e0 930d                      	st X+ ,r16 ;initalize LED display array
0000e1 930d                      	st X+ ,r16 ;initalize LED display array
                                 
0000e2 9508                      	ret
                                 
                                 ;*******************************************
                                 ;* 
                                 ;* "var_delay"
                                 ;*
                                 ;* Description: 25ms program software delay 
                                 ;*
                                 ;* Author: Aditya Jindal
                                 ;* Version: 1.0
                                 ;* Last updated: 10-29-2020
                                 ;* Target: ATmega4809
                                 ;* Number of words: 27
                                 ;* Number of cycles: 282
                                 ;* Low registers modified:
                                 ;* High registers modified: r16,r17
                                 ;*
                                 ;* Parameters: none
                                 ;* Returns: none
                                 ;*
                                 ;* Notes: 
                                 ;*
                                 ;*****************************************
                                 
                                 var_delay:
0000e3 ef0f                      	ldi r16, 255		;load r16 with 1-25ms
                                 outer_loop:
0000e4 e61e                      	ldi r17, 110		;load r17 with a second delay variable
                                 inner_loop:				;delay for the total decided time.
0000e5 951a                      	dec r17
0000e6 f7f1                      	brne inner_loop
0000e7 950a                      	dec r16
0000e8 f7d9                      	brne outer_loop
                                 
0000e9 9508                      	ret
                                 
                                 ;*******************************************
                                 ;* 
                                 ;* "one_sec_delay"
                                 ;*
                                 ;* Description: Program to repeatedly call
                                 ;*	var_delay for bigger delays 
                                 ;*
                                 ;* Author: Aditya Jindal
                                 ;* Version: 1.0
                                 ;* Last updated: 10-29-2020
                                 ;* Target: ATmega4809
                                 ;* Number of words: 27
                                 ;* Number of cycles: 282
                                 ;* Low registers modified: none
                                 ;* High registers modified: r18
                                 ;*
                                 ;* Parameters: r18
                                 ;* Returns: none
                                 ;*
                                 ;* Notes: 
                                 ;*
                                 ;*****************************************
                                 
                                 one_sec_delay:
0000ea dff8                      	rcall var_delay
0000eb 952a                      	dec r18
0000ec 3020                      	cpi r18, 0x00
0000ed f7e1                      	brne one_sec_delay	;keep looping till r18 zero
0000ee 9508                      	ret
                                 
                                 ;**************************************************
                                 ;* 
                                 ;* "multiplex_display"
                                 ;*
                                 ;* Description: outputs the segment values for the 
                                 ;*	next multiplexed digit to be displayed and turns
                                 ;*	ON that digit
                                 ;*
                                 ;* Author: Aditya Jindal
                                 ;* Version: 1.0
                                 ;* Last updated: 10-29-2020
                                 ;* Target: ATmega4809
                                 ;* Number of words: 32
                                 ;* Number of cycles: 36
                                 ;* Low registers modified: none
                                 ;* High registers modified: r16, r17, r18, r20, YH, YL
                                 ;*
                                 ;* Parameters: none
                                 ;* Returns: none
                                 ;*
                                 ;* Notes: 
                                 ;*
                                 ;***********************************************
                                 
                                 multiplex_display:
0000ef 9100 2808                 	lds r16, digit_num ;load digit num into r16
0000f1 7003                      	andi r16, 0x03	;mask it to get lsb
0000f2 2f10                      	mov r17,r16	;make a copy of r16
                                 	
0000f3 9310 2808                 	sts digit_num, r17	;load r17 into variable
                                 
0000f5 e0c4                      	ldi YL, LOW(led_display)	;set pointer
0000f6 e2d8                      	ldi YH, HIGH(led_display)
                                 	
0000f7 9503                      	inc r16	;increment register
                                 output_loop:
0000f8 950a                      	dec r16	;decremnt register
0000f9 9129                      	ld r18,Y+	;store incremented pointer value
0000fa f7e9                      	brne output_loop
                                 
                                 	
0000fb 3010                      	cpi r17,0 ;demux r17 to choose correct anode
0000fc f031                      	breq pos_zero	;branch to the right position
0000fd 3011                      	cpi r17,1	
0000fe f031                      	breq pos_one
0000ff 3012                      	cpi r17,2	
000100 f031                      	breq pos_two
000101 3013                      	cpi r17,3	
000102 f031                      	breq pos_three
                                 
                                 pos_zero:
000103 ee4f                      	ldi r20, 0xEF	;set r20 to the PC value
000104 c006                      	rjmp position	;branch to position
                                 pos_one:
000105 ed4f                      	ldi r20,0xDF
000106 c004                      	rjmp position
                                 
                                 pos_two:
000107 eb4f                      	ldi r20,0xBF
000108 c002                      	rjmp position
                                 
                                 pos_three:
000109 e74f                      	ldi r20, 0x7F
00010a c000                      	rjmp position
                                 
                                 position:
00010b ef3f                      	ldi r19, 0xFF
00010c b939                      	out VPORTC_OUT, r19	;turn off digit to modigy
00010d b92d                      	out VPORTD_OUT, r18	;output the right segment value
00010e b949                      	out VPORTC_OUT, r20 ;power common anode
00010f 9513                      	inc r17	;increment register
000110 9310 2808                 	sts digit_num, r17 ;store register in variable
                                 
000112 9508                      	ret
                                 
                                 
                                     ;************************************
                                 ;*
                                 ;* "bin2BCD16" - 16-bit Binary to BCD conversion
                                 ;*
                                 ;* This subroutine converts a 16-bit number 
                                 ;* (fbinH:fbinL) to a 5-digit packed BCD 
                                 ;* number represented by 3 bytes (tBCD2:tBCD1:tBCD0).
                                 ;* MSD of the 5-digit number is placed in the 
                                 ;*lowermost nibble of tBCD2.
                                 ;*
                                 ;* Number of words	:25
                                 ;* Number of cycles	:751/768 (Min/Max)
                                 ;* Low registers used	:3 (tBCD0,tBCD1,tBCD2)
                                 ;* High registers used  :4(fbinL,fbinH,cnt16a,tmp16a)	
                                 ;* Pointers used	:Z
                                 ;*
                                 ;******************************************
                                 
                                 ;***** Subroutine Register Variables
                                 
                                 .dseg
002809                           tBCD0: .byte 1  // BCD digits 1:0
00280a                           tBCD1: .byte 1  // BCD digits 3:2
00280b                           tBCD2: .byte 1  // BCD digits 4
                                 
                                 .cseg
                                 .def	tBCD0_reg = r13	;BCD value digits 1 and 0
                                 .def	tBCD1_reg = r14	;BCD value digits 3 and 2
                                 .def	tBCD2_reg = r15	;BCD value digit 4
                                 
                                 .def	fbinL = r16	;binary value Low byte
                                 .def	fbinH = r17	;binary value High byte
                                 
                                 .def	cnt16a	=r18	;loop counter
                                 .def	tmp16a	=r19	;temporary value
                                 
                                 ;***** Code
                                 
                                 bin2BCD16:
000113 930f                          push fbinL
000114 931f                          push fbinH
000115 932f                          push cnt16a
000116 933f                          push tmp16a
                                 
                                 
000117 e120                      	ldi	cnt16a, 16	;Init loop counter	
000118 e040                          ldi r20, 0x00
000119 9340 2809                     sts tBCD0, r20 ;clear result (3 bytes)
00011b 9340 280a                     sts tBCD1, r20
00011d 9340 280b                     sts tBCD2, r20
                                 bBCDx_1:
                                     // load values from memory
00011f 90d0 2809                     lds tBCD0_reg, tBCD0
000121 90e0 280a                     lds tBCD1_reg, tBCD1
000123 90f0 280b                     lds tBCD2_reg, tBCD2
                                 
000125 0f00                          lsl	fbinL	;shift input value
000126 1f11                      	rol	fbinH	;through all bytes
000127 1cdd                      	rol	tBCD0_reg		;
000128 1cee                      	rol	tBCD1_reg
000129 1cff                      	rol	tBCD2_reg
                                 
00012a 92d0 2809                     sts tBCD0, tBCD0_reg
00012c 92e0 280a                     sts tBCD1, tBCD1_reg
00012e 92f0 280b                     sts tBCD2, tBCD2_reg
                                 
000130 952a                      	dec	cnt16a		;decrement loop counter
000131 f429                      	brne bBCDx_2		;if counter not zero
                                 
000132 913f                          pop tmp16a
000133 912f                          pop cnt16a
000134 911f                          pop fbinH
000135 910f                          pop fbinL
000136 9508                      ret			; return
                                     bBCDx_2:
                                     // Z Points tBCD2 + 1, MSB of BCD result + 1
000137 e0ec                          ldi ZL, LOW(tBCD2 + 1)
000138 e2f8                          ldi ZH, HIGH(tBCD2 + 1)
                                     bBCDx_3:
000139 9132                      	    ld tmp16a, -Z ;get (Z) with pre-decrement
00013a 5f3d                      	    subi tmp16a, -$03;add 0x03
                                 
00013b fd33                      	    sbrc tmp16a, 3     ;if bit 3 not clear
00013c 8330                      	    st Z, tmp16a	   ;store back
                                 
00013d 8130                      	    ld tmp16a, Z	;get (Z)
00013e 5d30                      	    subi tmp16a, -$30	;add 0x30
                                 
00013f fd37                      	    sbrc tmp16a, 7	;if bit 7 not clear
000140 8330                              st Z, tmp16a	;	store back
                                 
000141 30e9                      	    cpi	ZL, LOW(tBCD0)	;done all three?
000142 f7b1                          brne bBCDx_3
000143 32f8                              cpi	ZH, HIGH(tBCD0)	;done all three?
000144 f7a1                          brne bBCDx_3
000145 cfd9                      rjmp bBCDx_1		
                                 
                                 
                                 
                                 ;***********************************************
                                 ;*
                                 ;* "BCD2bin16" - BCD to 16-Bit Binary Conversion
                                 ;*
                                 ;* This subroutine converts a 5-digit 
                                 ;* packed BCD number represented by
                                 ;* 3 bytes (fBCD2:fBCD1:fBCD0) to 
                                 ;* a 16-bit number (tbinH:tbinL).
                                 ;* MSD of the 5-digit number must be 
                                 ;* placed in the lowermost nibble of fBCD2.
                                 ;*
                                 ;* Let "abcde" denote the 5-digit number.
                                 ;* The conversion is done by
                                 ;* computing the formula: 10(10(10(10a+b)+c)+d)+e.
                                 ;* The subroutine "mul10a"/"mul10b" does 
                                 ;* the multiply-and-add operation
                                 ;* which is repeated four times during the computation.
                                 ;*
                                 ;* Number of words	:30
                                 ;* Number of cycles	:108
                                 ;* Low registers used	:4 (copyL,copyH,mp10L/tbinL,mp10H/tbinH)
                                 ;* High registers used  :4 (fBCD0,fBCD1,fBCD2,adder)	
                                 ;*
                                 ;*******************************************
                                 
                                 ;***** "mul10a"/"mul10b" Subroutine Register Variables
                                 
                                 .def	copyL	=r12;temporary register
                                 .def	copyH	=r13;temporary register
                                 .def	mp10L	=r14;Low byte of number to be multiplied by 10
                                 .def	mp10H	=r15;High byte of number to be multiplied by 10
                                 .def	adder	=r19;value to add after multiplication	
                                 
                                 ;***** Code
                                 
                                 mul10a:	;***** multiplies "mp10H:mp10L" with 
                                 ;* 10 and adds "adder" high nibble
000146 9532                      	swap	adder
                                 mul10b:	;***** multiplies "mp10H:mp10L" with
                                 ;* 10 and adds "adder" low nibble
000147 2cce                      	mov	copyL,mp10L	;make copy
000148 2cdf                      	mov	copyH,mp10H
000149 0cee                      	lsl	mp10L	;multiply original by 2
00014a 1cff                      	rol	mp10H
00014b 0ccc                      	lsl	copyL	;multiply copy by 2
00014c 1cdd                      	rol	copyH		
00014d 0ccc                      	lsl	copyL	;multiply copy by 2 (4)
00014e 1cdd                      	rol	copyH		
00014f 0ccc                      	lsl	copyL	;multiply copy by 2 (8)
000150 1cdd                      	rol	copyH		
000151 0cec                      	add	mp10L,copyL	;add copy to original
000152 1cfd                      	adc	mp10H,copyH	
000153 703f                      	andi	adder,0x0f	;mask away upper nibble of adder
000154 0ee3                      	add	mp10L,adder	;add lower nibble of adder
000155 f408                          brcc	m10_1	;if carry not cleared
000156 94f3                      	    inc	mp10H		;	inc high byte
                                     m10_1:
000157 9508                      ret	
                                 
                                 ;***** Main Routine Register Variables
                                 
                                 .def	tbinL	=r14;Low byte of binary result (same as mp10L)
                                 .def	tbinH	=r15;High byte of binary result (same as mp10H)
                                 .def	fBCD0	=r16;BCD value digits 1 and 0
                                 .def	fBCD1	=r17;BCD value digits 2 and 3
                                 .def	fBCD2	=r18;BCD value digit 5
                                 
                                 ;***** Code
                                 
                                 BCD2bin16:
000158 702f                      	andi	fBCD2,0x0f	;mask away upper nibble of fBCD2
000159 24ff                      	clr	mp10H		
00015a 2ee2                      	mov	mp10L,fBCD2	;mp10H:mp10L = a
00015b 2f31                      	mov	adder,fBCD1
00015c dfe9                      	rcall	mul10a		;mp10H:mp10L = 10a+b
00015d 2f31                      	mov	adder,fBCD1
00015e dfe8                      	rcall	mul10b		;mp10H:mp10L = 10(10a+b)+c
00015f 2f30                      	mov	adder,fBCD0		
000160 dfe5                      	rcall	mul10a		;mp10H:mp10L = 10(10(10a+b)+c)+d
000161 2f30                      	mov	adder,fBCD0
000162 dfe4                      	rcall	mul10b		;mp10H:mp10L = 10(10(10(10a+b)+c)+d)+e
000163 9508                      ret
                                 
                                 ;****************************************
                                 ;* 
                                 ;* "hex_to_7seg" - Hexadecimal to Seven Segment Conversion
                                 ;*
                                 ;* Description: Converts a right justified hexadecimal digit 
                                 ;*to the seven segment pattern required to display it. 
                                 ;*Pattern is right justified a through g. 
                                 ;*Pattern uses 0s to turn segments on ON.
                                 ;*
                                 ;* Author:						Ken Short
                                 ;* Version:						1.0						
                                 ;* Last updated:				101620
                                 ;* Target:						ATmega4809
                                 ;* Number of words:				8
                                 ;* Number of cycles:			13
                                 ;* Low registers modified:		none		
                                 ;* High registers modified:		r16, r18, ZL, ZH
                                 ;*
                                 ;* Parameters: r18: right justified hex digit, high nibble 0
                                 ;* Returns: r18: segment values a through g right justified
                                 ;*
                                 ;* Notes: 
                                 ;*
                                 ;****************************************
                                 
                                 hex_to_7seg:
000164 702f                      	andi r18, 0x0F				;clear ms nibble
000165 e0f2                          ldi ZH, HIGH(hextable * 2)  ;set Z to point start table
000166 ede8                          ldi ZL, LOW(hextable * 2)
000167 e000                          ldi r16, $00                ;add offset to Z pointer
000168 0fe2                          add ZL, r18
000169 1ff0                          adc ZH, r16
00016a 9124                          lpm r18, Z                  ;load byte from table
00016b 9508                      	ret
                                 
                                     ;Table of segment values to display digits 0 - F
                                     ;!!! seven values must be added - verify all values
00016c 4f01
00016d 0612
00016e 244c
00016f 0f20
000170 0c00
000171 6008
000172 4231
000173 3830                      hextable: .db $01,$4F,$12,$06,$4C,$24,$20,$0F,$00,$0C,$08,$60,$31,$42,$30,$38


RESOURCE USE INFORMATION
------------------------

Notice:
The register and instruction counts are symbol table hit counts,
and hence implicitly used resources are not counted, eg, the
'lpm' instruction without operands implicitly uses r0 and z,
none of which are counted.

x,y,z are separate entities in the symbol table and are
counted separately from r26..r31 here.

.dseg memory usage only counts static data declared with .byte

"ATmega4809" register use summary:
x  :  16 y  :   5 z  :   5 r0 :   0 r1 :   0 r2 :   0 r3 :   0 r4 :   0 
r5 :   0 r6 :   0 r7 :   0 r8 :   0 r9 :   0 r10:   0 r11:   0 r12:   5 
r13:  10 r14:  10 r15:   8 r16:  80 r17:  22 r18:  41 r19:  31 r20:  18 
r21:   5 r22:   4 r23:   2 r24:   2 r25:   0 r26:   4 r27:   4 r28:   6 
r29:   6 r30:   4 r31:   4 
Registers used: 22 out of 35 (62.9%)

"ATmega4809" instruction use summary:
.lds  :   0 .sts  :   0 adc   :   3 add   :   4 adiw  :   0 and   :   0 
andi  :   4 asr   :   0 bclr  :   0 bld   :   0 brbc  :   0 brbs  :   0 
brcc  :   2 brcs  :   0 break :   0 breq  :   4 brge  :   0 brhc  :   0 
brhs  :   0 brid  :   0 brie  :   0 brlo  :   0 brlt  :   0 brmi  :   0 
brne  :   9 brpl  :   0 brsh  :   0 brtc  :   0 brts  :   0 brvc  :   0 
brvs  :   0 bset  :   0 bst   :   0 call  :   0 cbi   :   0 cbr   :   0 
clc   :   0 clh   :   0 cli   :   0 cln   :   0 clr   :   3 cls   :   0 
clt   :   0 clv   :   0 clz   :   0 com   :   0 cp    :   0 cpc   :   0 
cpi   :   7 cpse  :   0 dec   :   7 des   :   0 eor   :   0 fmul  :   0 
fmuls :   0 fmulsu:   0 icall :   0 ijmp  :   0 in    :   2 inc   :   3 
jmp   :   3 ld    :   3 ldd   :   0 ldi   :  53 lds   :   6 lpm   :   2 
lsl   :   5 lsr   :  10 mov   :  17 movw  :   0 mul   :   0 muls  :   0 
mulsu :   0 neg   :   0 nop   :   0 or    :   0 ori   :   0 out   :   7 
pop   :  20 push  :  20 rcall :  16 ret   :  10 reti  :   2 rjmp  :   6 
rol   :   8 ror   :   6 sbc   :   1 sbci  :   0 sbi   :   0 sbic  :   0 
sbis  :   0 sbiw  :   0 sbr   :   0 sbrc  :   2 sbrs  :   0 sec   :   0 
seh   :   0 sei   :   1 sen   :   0 ser   :   0 ses   :   0 set   :   0 
sev   :   0 sez   :   0 sleep :   0 spm   :   0 st    :  18 std   :   4 
sts   :  22 sub   :   1 subi  :   2 swap  :   1 tst   :   0 wdr   :   0 

Instructions used: 37 out of 114 (32.5%)

"ATmega4809" memory use summary [bytes]:
Segment   Begin    End      Code   Data   Used    Size   Use%
---------------------------------------------------------------
[.cseg] 0x000000 0x0002e8    648     16    664   49152   1.4%
[.dseg] 0x002800 0x00280c      0     12     12    6144   0.2%
[.eseg] 0x000000 0x000000      0      0      0     256   0.0%

Assembly complete, 0 errors, 15 warnings
